---
layout: single
title:  "깊이 우선 탐색 & 너비 우선 탐색"
---
# 깊이 우선 탐색(depth first search, DFS)  
## 깊이 우선 탐색이란?  
그래프에서 깊이 우선 탐색은 먼저 시작 정점에서부터 임의의 인접한 정점으로 깊이 탐색을 진행한다. 이때 방문한 정점은 반드시 방문되었다는 표시를 해야 하고, 탐색은 아직 방문하지 않은 인접 정점으로만 가능하다. 만약 현재 정점에서 더 이상 방문하지 않은 인접 정점이 없으면 가장 마지막에 만났던 정점으로 되돌아간다. 거기서 다시 아직 방문하지 않은 인접 정점을 찾아 다시 동일한 방벙의 탐색을 진행한다.  
![BFS](/BFS.png)

## 탐색 기능을 가진 그래프 클래스(인접 행렬 사용)
```c++
#include <iostream>
using namespace std;
#define MAX_VTXS 256

class AdjMatGraph {
protected:
	int size;
	char vertices[MAX_VTXS];
	int adj[MAX_VTXS][MAX_VTXS];
public:
	AdjMatGraph() { reset(); }
	char getVertex(int i) { return vertices[i]; }
	int getEdge(int i, int j) { return adj[i][j]; }
	void setEdge(int i, int j, int val) { adj[i][j] = val; }
	bool isEmpty()	{ return size == 0; }
	bool isFull() { return size >= MAX_VTXS; }

	void reset() {
		size = 0;
		for (int i = 0; i < MAX_VTXS; i++)
			for (int j = 0; j < MAX_VTXS; j++)
				setEdge(i, j, 0);

	}

	void insertEdge(int u, int v) {
		setEdge(u, v, 1);
		setEdge(v, u, 1);
	}

};

class SrchAMGraph : public AdjMatGraph
{
	bool visited[MAX_VTXS];
public:
	void resetVisited() {
		for (int i = 0; i < size; i++)
			visited[i] = false;
	}

	bool isLinked(int u, int v) { return getEdge(u, v) != 0; }

	void DFS(int v) {
		visited[v] = true;
		printf("%c ", getVertex(v));

		for (int w = 0; w < size; w++)
			if (isLinked(v, w) && visited[w] == false)
				DFS(w);
	}
};
```
## 탐색 기능을 가진 인접 리스트를 이용한 그래프 클래스
```c++
#include <iostream>
using namespace std;
#define MAX_VTXS 256

class Node {
protected:
	int id;
	Node* link;
public:
	Node(int i, Node *l=NULL) : id(i), link(l) {}
	~Node() {
		if (link != NULL) delete link;
	}
	int getID()	{ return id; }
	Node* getLink() { return link;}
	void setLink(Node* l) { link = l; }
};

class AdjListGraph {
protected:
	int size;
	char vertices[MAX_VTXS];
	Node* adj[MAX_VTXS];
public:
	AdjListGraph() : size(0) {}
	~AdjListGraph() { reset(); }
	void reset(void) {
		for (int i = 0; i < size; i++)
			if (adj[i] != NULL) delete adj[i];
		size = 0;
	}
	bool isEmpty() { return (size == 0); }
	bool isFull() { return (size >= MAX_VTXS); }
	char getVertex(int i) { return vertices[i]; }

	void insertVertex(char val) {
		if (!isFull()) {
			vertices[size] = val;
			adj[size++] = NULL;
		}
		else printf("Error: 그래프 정점 개수 초과\n");
	}

	void insertEdge(int u, int v) {
		adj[u] = new Node(v, adj[u]);
		adj[v] = new Node(u, adj[v]);
	}

};

class SrchALGraph : public AdjListGraph
{
	bool visited[MAX_VTXS];
public:
	void resetVisited() {
		for (int i = 0; i < size; i++)
			visited[i] = false;
	}
	bool isLinked(int u, int v) {
		for (Node* p = adj[u]; p != NULL; p = p->getLink())
			if (p->getID() == v) return true;
		return false;
	}

	void DFS(int v) {
		visited[v] = true;
		printf("%c ", getVertex(v));

		for (Node* p = adj[v]; p != NULL; p = p->getLink())
			if (visited[p->getID()] == false)
				DFS(p->getID());
	}
};
```
