---
layout: single
title:  "Assignment02"
---

# 1. Solve the problems 34 in chapter 1. 
![2023-03-14](https://user-images.githubusercontent.com/113247511/224741521-051eb256-70dc-4846-8d52-4ebfc0288c38.png)
해당 코드를 살펴보면, n에 2의 거듭제곱이 대입될 때마다 whlie문 시행 횟수가 변화한다.  
n이 1일 때는 외부 루프가 1번, 내부 루프가 1번 실행된다.  
n이 2일 때는 외부 루프가 2번, 내부 루프는 각각 1번, 2번, 총 3번이 실행된다.  
n이 4일 때는 외부 루프가 3번, 내부 루프는 각각 1번, 2번, 3번 총 6번이 실행된다.  
n이 8일 때는 외부 루프가 4번, 내부 루프는 각각 1번, 2번, 3번, 4번 총 10번이 실행된다.  
규칙을 발견하였으나 이를 이용하여 복잡도를 구하지는 못하였다. 

# 2. Apply sorting algorithms to the birthday dataset. 
## Permutation Sort
```python
def permutation_sort(A):
  for B in permutations(A):
    if is_sorted(B):
      return B
```
## Selection Sort
```python
def prefix_max(A, i):
  '''Return index of maximum in A[:i + 1]'''
  if i > 0:
    j = prefix_max(A, i-1)
    if A[i] < A[j]:
      return j
    return i

def selection_sort (A, i = None) :
  '''Sort A[:i + 1]'''
  if i is None: i = len(A) - 1
    j = prefix_max(A, i)
    A[i], A[j] = A[j], A[i]
    selection_sort(A, i - 1)
```
## Insertion Sort
```python
def Insertion_Sort(array):
    for a in range(1, len(array)):
        for b in range(a, 0, -1):
            if array[b] < array[b-1]:
                   array[b], array[b-1] = array[b-1], array[b]
            else:
                   break
    return array
```
## Merge Sort
```python
def merge(L, R, A, i, j, a, b):
  '''Merge sorted L[:i] and R[:j] into A[a:b]'''
  if a < b:
    if (j <= 0) or (i > 0 and L[i - 1] > R[j - 1]) :
      A[b - 1] = L[i - 1]
      i = i - 1
  else:
    A[b- 1] = R[j - 1]
    j = j - 1
merge(L, R, A, i, j, a, b - 1)

def merge_sort(A, a = 0, b = None) :
  if b is None: b = len(A)
  if 1< b-a:
    c = (a+b+1) // 2
    merge_sort(A, a, c)
    merge_sort(A, c, b)
    L, R = A[a:c], A[c:b]
    merge(L, R, A, len(:), len(R), a, b)
```
